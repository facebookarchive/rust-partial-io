/*
 *  Copyright (c) 2017-present, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 */
//! This module contains an `AsyncRead` wrapper that breaks its inputs up
//! according to a provided iterator.
//!
//! This is separate from `PartialWrite` because on `WouldBlock` errors, it
//! causes `futures` to try writing or flushing again.

use std::cmp;
use std::io::{self, Read};

use futures::task;
use tokio_io::AsyncRead;

use {PartialOp, make_ops};

/// A wrapper that breaks inner `AsyncRead` instances up according to the
/// provided iterator.
///
/// Available with the `tokio` feature.
///
/// # Examples
///
/// ```rust
/// extern crate partial_io;
/// extern crate tokio_core;
/// extern crate tokio_io;
///
/// use std::io::{self, Cursor};
///
/// fn main() {
///     use tokio_core::reactor::Core;
///     use tokio_io::io::read as tokio_read;
///
///     use partial_io::{PartialAsyncRead, PartialOp};
///
///     let reader = Cursor::new(vec![1, 2, 3, 4]);
///     let iter = vec![PartialOp::Err(io::ErrorKind::WouldBlock), PartialOp::Limited(2)];
///     let partial_reader = PartialAsyncRead::new(reader, iter);
///     let out = vec![0; 256];
///
///     let mut core = Core::new().unwrap();
///
///     // This future will skip over the WouldBlock and return however much was
///     // successfully read the first time a read succeeded.
///     let read_fut = tokio_read(partial_reader, out);
///
///     let (_partial_reader, out, size) = core.run(read_fut).unwrap();
///
///     assert_eq!(size, 2);
///     assert_eq!(&out[..3], &[1, 2, 0]);
/// }
/// ```
pub struct PartialAsyncRead<R> {
    inner: R,
    ops: Box<Iterator<Item = PartialOp>>,
}

impl<R> PartialAsyncRead<R>
    where R: AsyncRead
{
    /// Creates a new `PartialAsyncRead` wrapper over the reader with the specified `PartialOp`s.
    pub fn new<I>(inner: R, iter: I) -> Self
        where I: IntoIterator<Item = PartialOp> + 'static
    {
        PartialAsyncRead {
            inner: inner,
            ops: make_ops(iter),
        }
    }

    /// Sets the `PartialOp`s for this reader.
    pub fn set_ops<I>(&mut self, iter: I) -> &mut Self
        where I: IntoIterator<Item = PartialOp> + 'static
    {
        self.ops = make_ops(iter);
        self
    }

    /// Acquires a reference to the underlying reader.
    pub fn get_ref(&self) -> &R {
        &self.inner
    }

    /// Acquires a mutable reference to the underlying reader.
    pub fn get_mut(&mut self) -> &mut R {
        &mut self.inner
    }

    /// Consumes this wrapper, returning the underlying reader.
    pub fn into_inner(self) -> R {
        self.inner
    }
}

impl<R> Read for PartialAsyncRead<R>
    where R: AsyncRead
{
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        match self.ops.next() {
            Some(PartialOp::Limited(n)) => {
                let len = cmp::min(n, buf.len());
                self.inner.read(&mut buf[..len])
            }
            Some(PartialOp::Err(err)) => {
                if err == io::ErrorKind::WouldBlock {
                    // Make sure this task is rechecked.
                    task::park().unpark();
                }
                Err(io::Error::new(err, "error during read, generated by partial-io"))
            }
            Some(PartialOp::Unlimited) |
            None => self.inner.read(buf),
        }
    }
}

impl<R> AsyncRead for PartialAsyncRead<R> where R: AsyncRead {}
