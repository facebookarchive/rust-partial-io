<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `partial_io` crate."><meta name="keywords" content="rust, rustlang, rust-lang, partial_io"><title>partial_io - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../partial_io/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate partial_io</p><div class="block version"><p>Version 0.4.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all partial_io's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div><p class="location"></p><script>window.sidebarCurrent = {name: "partial_io", ty: "mod", relpath: "../"};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/partial_io/lib.rs.html#8-153" title="goto source code">[src]</a></span><span class="in-band">Crate <a class="mod" href="">partial_io</a></span></h1><div class="docblock"><p>Helpers for testing I/O behavior with partial, interrupted and blocking reads and writes.</p>
<p>This library provides:</p>
<ul>
<li><code>PartialRead</code> and <code>PartialWrite</code>, which wrap existing <code>Read</code> and
<code>Write</code> implementations and allow specifying arbitrary behavior on the
next <code>read</code>, <code>write</code> or <code>flush</code> call.</li>
<li>With the optional <code>futures03</code> and <code>tokio02</code> features, <code>PartialAsyncRead</code> and
<code>PartialAsyncWrite</code> to wrap existing <code>AsyncRead</code> and <code>AsyncWrite</code>
implementations. These implementations are task-aware, so they will know
how to pause and unpause tasks if they return a <code>WouldBlock</code> error.</li>
<li>With the optional <code>quickcheck1</code> feature, generation of random sequences of
operations which can be provided to one of the wrappers. See the
<code>quickcheck_types</code> documentation for more.</li>
</ul>
<h1 id="motivation" class="section-header"><a href="#motivation">Motivation</a></h1>
<p>A <code>Read</code> or <code>Write</code> wrapper is conceptually simple but can be difficult to
get right, especially if the wrapper has an internal buffer. Common
issues include:</p>
<ul>
<li>A partial read or write, even without an error, might leave the wrapper
in an invalid state (<a href="https://github.com/gyscos/zstd-rs/commit/3123e418595f6badd5b06db2a14c4ff4555e7705">example fix</a>).</li>
</ul>
<p>With the <code>AsyncRead</code> and <code>AsyncWrite</code> provided by <code>futures03</code> and <code>tokio02</code>:</p>
<ul>
<li>A call to <code>read_to_end</code> or <code>write_all</code> within the wrapper might be partly
successful but then error out. These functions will return the error
without informing the caller of how much was read or written. Wrappers
with an internal buffer will want to advance their state corresponding
to the partial success, so they can't use <code>read_to_end</code> or <code>write_all</code>
(<a href="https://github.com/gyscos/zstd-rs/commit/02dc9d9a3419618fc729542b45c96c32b0f178bb">example fix</a>).</li>
<li>Instances must propagate <code>Poll::Pending</code> up, but that shouldn't leave
them in an invalid state.</li>
</ul>
<p>These situations can be hard to think about and hard to test.</p>
<p><code>partial-io</code> can help in two ways:</p>
<ol>
<li>For a known bug involving any of these situations, <code>partial-io</code> can help
you write a test.</li>
<li>With the <code>quickcheck1</code> feature enabled, <code>partial-io</code> can also help shake
out bugs in your wrapper. See <code>quickcheck_types</code> for more.</li>
</ol>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::{<span class="self">self</span>, <span class="ident">Cursor</span>, <span class="ident">Read</span>};

<span class="kw">use</span> <span class="ident">partial_io</span>::{<span class="ident">PartialOp</span>, <span class="ident">PartialRead</span>};

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">b&quot;Hello, world!&quot;</span>.<span class="ident">to_vec</span>();
<span class="kw">let</span> <span class="ident">cursor</span> <span class="op">=</span> <span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="ident">data</span>);  <span class="comment">// Cursor&lt;Vec&lt;u8&gt;&gt; implements io::Read</span>
<span class="kw">let</span> <span class="ident">ops</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="ident">PartialOp</span>::<span class="ident">Limited</span>(<span class="number">7</span>), <span class="ident">PartialOp</span>::<span class="prelude-val">Err</span>(<span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">Interrupted</span>)];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">partial_read</span> <span class="op">=</span> <span class="ident">PartialRead</span>::<span class="ident">new</span>(<span class="ident">cursor</span>, <span class="ident">ops</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">256</span>];

<span class="comment">// The first read will read 7 bytes.</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">partial_read</span>.<span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out</span>).<span class="ident">unwrap</span>(), <span class="number">7</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">out</span>[..<span class="number">7</span>], <span class="string">b&quot;Hello, &quot;</span>);
<span class="comment">// The second read will fail with ErrorKind::Interrupted.</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">partial_read</span>.<span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out</span>[<span class="number">7</span>..]).<span class="ident">unwrap_err</span>().<span class="ident">kind</span>(), <span class="ident">io</span>::<span class="ident">ErrorKind</span>::<span class="ident">Interrupted</span>);
<span class="comment">// The iterator has run out of operations, so it no longer truncates reads.</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">partial_read</span>.<span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out</span>[<span class="number">7</span>..]).<span class="ident">unwrap</span>(), <span class="number">6</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">out</span>[..<span class="number">13</span>], <span class="string">b&quot;Hello, world!&quot;</span>);</pre></div>
<p>For a real-world example, see the <a href="https://github.com/gyscos/zstd-rs/blob/master/src/stream/mod.rs">tests in <code>zstd-rs</code></a>.</p>
</div><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="quickcheck_types/index.html" title="partial_io::quickcheck_types mod">quickcheck_types</a></td><td class="docblock-short"><p><code>QuickCheck</code> support for partial IO operations.</p>
</td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.PartialAsyncRead.html" title="partial_io::PartialAsyncRead struct">PartialAsyncRead</a></td><td class="docblock-short"><p>A wrapper that breaks inner <code>AsyncRead</code> instances up according to the
provided iterator.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PartialAsyncWrite.html" title="partial_io::PartialAsyncWrite struct">PartialAsyncWrite</a></td><td class="docblock-short"><p>A wrapper that breaks inner <code>AsyncWrite</code> instances up according to the
provided iterator.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PartialRead.html" title="partial_io::PartialRead struct">PartialRead</a></td><td class="docblock-short"><p>A reader wrapper that breaks inner <code>Read</code> instances up according to the
provided iterator.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PartialWrite.html" title="partial_io::PartialWrite struct">PartialWrite</a></td><td class="docblock-short"><p>A writer wrapper that breaks inner <code>Write</code> instances up according to the
provided iterator.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.PartialOp.html" title="partial_io::PartialOp enum">PartialOp</a></td><td class="docblock-short"><p>What to do the next time an IO operation is performed.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "partial_io";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>